package ais;

import galaxy.Planet;
import galaxy.Player;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class QuickStartAI extends Player {
   
   long turnCount = 0;
   int myTotalUnits = 0;
   int enemyTotalUnits = 0;
   
   public QuickStartAI() {
      super(new Color(0,100,100), "Frisk AI");
   }
   
   public QuickStartAI(Color c) {
      super(c, "Frisk AI");
   }

   public double getPlanetThreat(Planet p, List<Planet> enemyPlanets) {
      double threat = 0;
      
      //Add threat level generated by enemy planets
      for(Planet t: enemyPlanets) {
         threat += t.getNumUnits() / (p.distanceTo(t) - 1);
      }
      //System.out.println("Threat: " + threat);
      return threat;
   }
   
   public double getPlanetSafety(Planet p, List<Planet> myPlanets) {
      double safety = 0;
      
      //Add safety level generated by own planets
      for(Planet s: myPlanets) {
         if(!p.equals(s)) {
            safety += s.getNumUnits() / (p.distanceTo(s));
            //System.out.println("ITS ME!");
         }
      }
      //System.out.println("Safe: " + safety);
      return safety;
   }
   
   public double getValue(Planet p) {
      Planet nearestEnemy = PlayerUtils.getNearestEnemyPlanet(planets, p, this);
      Planet nearestOwn = PlayerUtils.getNearestOwnedPlanet(planets, p, this);
      double distToAlly = nearestOwn != null ? p.distanceTo(nearestOwn) : 9999;
      double distToEnemy = nearestEnemy != null ? p.distanceTo(nearestEnemy) : 9999;
      double value;
      
      value = 100 / (p.PRODUCTION_TIME + p.getNumUnits() * 3);
      value *= distToAlly + distToEnemy / 2;
      
      if(myTotalUnits > enemyTotalUnits * 1.2) {
         if(!p.isNeutral()) {
            value *= 2;
         }
      }
      
      return value;
   }
   
   public List<Planet> sortByValue(List<Planet> planets) {
      ArrayList<Planet> rtn = new ArrayList<Planet>(planets);
      Collections.sort(rtn, (a, b) -> {
         return Double.compare(getValue(b), getValue(a));
      });
      return rtn;
   }
   
   @Override
   protected void turn() {
      List<Planet> myPlanets = PlayerUtils.getPlanetsOwnedByPlayer(planets, this);
      List<Planet> enemyPlanets = PlayerUtils.getOpponentsPlanets(planets, this);
      List<Planet> otherPlanets = PlayerUtils.getPlanetsNotOwnedByPlayer(planets, this);
      List<Planet> unnocPlanets = PlayerUtils.getUnoccupiedPlanets(planets);
      List<Planet> sortedByValue;
      double safety;
      double threat;
      ArrayList<Integer> neededUnits = new ArrayList<Integer>();
      ArrayList<Integer> wantedUnits = new ArrayList<Integer>();
      int totalNeededUnits = 0;
      int totalExtraUnits = 0;
      
      int myTotalPlanetUnits = PlayerUtils.getMyUnitsOnPlanets(planets, this);
      int myTotalFleetUnits = PlayerUtils.getMyUnitsInFleets(fleets, this);
      int enemyTotalPlanetUnits = PlayerUtils.getEnemyUnitsOnPlanets(planets, this);
      int enemyTotalFleetUnits = PlayerUtils.getEnemyUnitsInFleets(fleets, this);
      myTotalUnits = myTotalPlanetUnits + myTotalFleetUnits;
      enemyTotalUnits = enemyTotalPlanetUnits + enemyTotalFleetUnits;
      
      //sortedByValue = sortByValue(unnocPlanets);
      //System.out.println("MINE:" + myTotalPlanetUnits + ", Theirs: " + enemyTotalPlanetUnits);
      System.out.println("TURN: " + turnCount);
      if(turnCount < 1) {
         sortedByValue = sortByValue(unnocPlanets);
         for(Planet p: myPlanets) {
            int tempUnits = p.getNumUnits();
            while(tempUnits > 10 && sortedByValue.size() > 0 && sortedByValue.get(0).getNumUnits() < tempUnits - 15) {
               addAction(p, sortedByValue.get(0), sortedByValue.get(0).getNumUnits() + 5);
               tempUnits -= sortedByValue.get(0).getNumUnits() + 5;
               sortedByValue.remove(0);
            }
         }
      }
      else {
         sortedByValue = sortByValue(otherPlanets);
         for(Planet p: myPlanets) {
            int tempUnits = p.getNumUnits();
            while(tempUnits > 10 && sortedByValue.size() > 0 && sortedByValue.get(0).getNumUnits() < tempUnits - 15) {
               addAction(p, sortedByValue.get(0), sortedByValue.get(0).getNumUnits() + 5);
               tempUnits -= sortedByValue.get(0).getNumUnits() + 5;
               sortedByValue.remove(0);
            }
         }
         
      }
      /*
      for(Planet p: myPlanets) {
         safety = getPlanetSafety(p, myPlanets);
         threat = getPlanetThreat(p, enemyPlanets);
         //negative neededUnits means units to spare
         neededUnits.add(PlanetUtils.getOpponentsIncomingFleetCount(p, fleets, this) - p.getNumUnits());
         wantedUnits.add((int) (threat / safety));
         if(neededUnits.get(neededUnits.size() - 1) > 0) {
            totalNeededUnits += neededUnits.get(neededUnits.size() - 1);
         }
         else {
            totalExtraUnits -= neededUnits.get(neededUnits.size() - 1);
         }
         
//         if(sortedByValue.size() != 0 && p.getNumUnits() > sortedByValue.get(0).getNumUnits() + 5) {
//            addAction(p, sortedByValue.get(0), sortedByValue.get(0).getNumUnits() + 5);
//         }
         
      }
      
      for(int i = 0; i < myPlanets.size(); i++) {
         if(totalExtraUnits > neededUnits.get(i) && neededUnits.get(i) > 0) {
            for(int j = 0; j < myPlanets.size(); i++) {
               if(i != j && neededUnits.get(j) < 0) { //meaning they have units to spare
                  addAction(myPlanets.get(j), myPlanets.get(i), neededUnits.get(i));
                  totalExtraUnits += neededUnits.get(j); //
                  neededUnits.set(j, neededUnits.get(j) + neededUnits.get(i));
                  neededUnits.set(i, neededUnits.get(j) + neededUnits.get(i));
               }
            }
         }
      }*/
      turnCount++;
   }

   @Override
   protected void newGame() {
      
   }

   @Override
   protected String storeSelf() {
      return null;
   }
}
